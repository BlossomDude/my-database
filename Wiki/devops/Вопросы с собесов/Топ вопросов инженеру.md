---
Owner: Blossom Dude
Last edited time: 2024-05-26T16:55
Created time: 2024-05-15T15:29
---
- ==**Опиши архитектуру кубернетес кластера, из чего состоит?**==
    
    - ==**Control Plane (master-node) :**==
        
        ==API Server== - служит как точка входа в Kubernetes API, через который все операции кластера управляются.
        
        ==etcd== - надежное хранилище данных, которое сохраняет конфигурацию и состояние кластера
        
        ==Scheduler== - отвечает за размещение подов (pods) на узлах в соответствии с ресурсными требованиями и другими ограничениями.
        
        ==Contoller manager== - управляет контроллерами, которые регулируют (и следят за требуемым состоянием) состояние кластера, например, контроллер репликаций.
        
    - ==**Worker nodes:**==
        
        ==**Kubelet**== - агент который работает на каждом узле и управляет объектами k8s
        
        ==**Kube-Proxy**== - сетевой прокси, который отвечает за маршрутизацию сетевого трафика к подам с учётом IP-адресов и портов сервисов Kubernetes.
        
        ==**Container Runtime**== - программное обеспечение для запуска контейнеров.
        
    - ==**Add-ons:**==
        
        ==**DNS**== - сервис для обнаружение сервисов и подов внутри кластера по именам.
        
        ==**Web UI**== - графический интерфейс пользователя для управления и мониторинка кластера k8s
        
        ==**Ingress Controller**== - компонент для управдения внешним доступом к сервисам в кластере, обычно HTTP/HTTPS
        
    - **==Pods:==**
        
        **==Pod==** - Базовая еденица развертывания в k8s, которая содержит один или несколько контейнеров, который разделяют хранилище и сетевой стек.
        
    
    > [!important]  
    > Эти компоненты взаимодействуют с друг другом для предоставления платформы, которая автоматизирует развертывание, масштабирования и управление приложениями в контейнерах.  
    
      
    
- ==**OOM Killer, что это и для чего он нужен?**==
    
    ==OOM Killer (out of memory)== - это механизм для ОС Линукс который используется для обработки ситуаций когда нет свободной оперативной памяти и своп израсходован.
    
    - **==Как работает OOM Killer:==**
        1. Когда система достигает критического уровня использования памяти, ядро пытается освободить память, останавливая процессы.
        2. Ядро оценивает все запущенные процессы и присваивает каждому из них "==оценку OOM==", которая определяет вероятность его завершения.
        3. Процесс с самой высокой оценкой OOM считается наименее важным или наиболее жадным в плане использования памяти и становится кандидатом на завершение.
        4. OOM Killer завершает выбранный процесс, освобождая память для других процессов и предотвращая полную блокировку системы.
    - ==**Для чего нужен OOM Killer**====:==
        - **Предотвращение блокировки**: Без OOM Killer система может полностью заблокироваться, если закончится память, что приведёт к невозможности запуска новых процессов или даже к сбою системы.
        - **Автоматическое управление ресурсами**: OOM Killer автоматически управляет ресурсами памяти, когда административное вмешательство невозможно.
        - **Стабильность системы**: Он помогает поддерживать стабильность системы, автоматически решая проблемы с памятью, которые могут возникнуть из-за неправильно сконфигурированных приложений или утечек памяти.
    
    > [!important]  
    > OOM Killer является важным механизмом защиты в Linux, который помогает поддерживать работоспособность системы в условиях нехватки памяти.  
    
- **==От кого по умолчанию запускается контейнер? Почему это плохо?==**
    
    ==**По умолчанию контейнер в docker запускается от рута.**==
    
    Это влечет с собой определенные риски, так как изоляция, обеспечиваемая контейнерами не достаточно сильна, чтобы полностью отделить пользователя контейнера от пользователя ядра.
    
    ==Root в контейнере – это тот же root, что и root на вашем хосте,== поэтому успешная компрометация может обеспечить контроль над вашей машиной.
    
- **==Что такое Readiness, Liveness, Startup пробы, какое отличие?==**
    
    ==**K8s probes**== - это проверки, которые осуществляются в течении жизненного цикла PODа. Они описываются для каждого контейнера.
    
    - ==**Startup probe**== - запускается сразу после старта пода и применяется для приложений, которые имеют длительную загрузку. ==Пока она не завершена, другие пробы не запускаются.==
    - ==**Readiness probe**== - проверка готовности пода обрабатывать трафик. Если проверка не пройдена, под не добавляется в маршрутизацию трафика сервиса.
    - ==**Liveness probe**== - проверяет, функционирует ли приложение. В случае если проверка не пройдена, то приложение перезапускается.
    
    > [!important]  
    > Readiness и liveness — независимые и запускаются после прохождения startup probe.  
      
    > [!important]  
    > Существуют exec-, http-, tcp- и gprc-пробы. Проверки осуществляются сервисом kubelet на ноде, где запущен целевой POD.  
    
      
    
- **==Отличие hardlink от symlink==**
    
    ==**Hard links**== — это файлы, которые указывают на данные на жёстком диске. Они являются зеркальными копиями исходного файла.
    
    ==**Soft links**== — это файлы, которые указывают на путь к данным. Они не являются отдельными файлами и не хранят данные, а указывают на имя исходного файла.
    
      
    
- **Как TCP устанавливает соединение?**
    
    ==**Установка соединения:**==
    
    SYN →  
    ← SYN ACK  
    ACK →  
    
    **==Разрыв:==**
    
    FIN →
    
    ← ACK
    
    ← FIN
    
    ACK →
    
    ==**Или разрыв в критической ситуации:**==
    
    RST →
    
      
    
- ==**Чем симметричное шифрование отличается от ассиметричного?**==
    
    ==Симметричное шифрование== - используется один ключ для шифрования и расшифрования
    
    ==Ассимитричное шифрование== - Используется публичный ключ для шифрования и закрытый для расшифрования.
    
- **DaemonSet зачем нужен для чего его обычно используют?**
    
      
    
    Это ресурс k8s, который обеспечивает запуск указанного одного Pod на всех узлак кластера или определенном подмножестве узлов в кластере.
    
      
    
    DaemosSet может быть использован для ведения журнала и мониторинга. Часто используется для запуска агентов для мониторинга на каждом узле кластера.
    
- ==**Политики taints и tolerations**==
    
    **==Taints==** — это особые политики, которые присваиваются узлам в группе. С помощью taint-политик можно запретить некоторым подам выполняться на определенных узлах. Например, можно указать, что поды для рендеринга должны запускаться только на [узлах с GPU](https://yandex.cloud/ru/docs/managed-kubernetes/concepts/node-group/node-group-gpu).  
      
      
    ==Преимущества использования taint-политик:==
    
    - политики сохраняются, когда узел перезапускается или заменяется новым;
    - при добавлении узлов в группу политики назначаются этому узлу автоматически;
    - политики автоматически назначаются новым узлам при [масштабировании группы узлов](https://yandex.cloud/ru/docs/managed-kubernetes/concepts/autoscale).
    
    Каждая taint-политика состоит из трех частей: `<ключ> = <значение>:<эффект>`
    
    Список доступных taint-эффектов:
    
    - `NO_SCHEDULE` — запретить запуск новых подов на узлах группы (уже запущенные поды продолжат работу);
    - `PREFER_NO_SCHEDULE` — избегать запуска подов на узлах группы, если для запуска этих подов есть свободные ресурсы в других группах;
    - `NO_EXECUTE` — завершить работу подов на узлах этой группы, расселить их в другие группы, а запуск новых подов запретить.
    
    ==**_Tolerations_**== — это исключения из taint-политик. С помощью tolerations можно разрешить определенным подам работать на узлах, даже если taint-политика группы узлов препятствует этому.
    
    Например, если для узлов в группе настроена taint-политика `key1=value1:NoSchedule`, разместить поды на таком узле можно с помощью tolerations:
    
    `apiVersion: v1 kind: Pod ... spec: ... tolerations: - key: "key1" operator: "Equal" value: "value1" effect: "NoSchedule"`
    
    **Примечание**
    
    Для системных подов автоматически назначаются tolerations, позволяющие им работать на всех доступных узлах.
    
- Что такое Requests, Limits?
    
    ==**Requests**== – это количество ресурсов, которое Kubernetes гарантированно выделит поду. Если вы укажете запрос на ресурсы, например, CPU или память, Kubernetes попытается запланировать под на узле, где эти ресурсы доступны. Это минимальное количество ресурсов, которое поду нужно для запуска.
    
    ==**Limits**== – это максимальное количество ресурсов, которое под может использовать. Если под превышает ограничение ресурсов, он может быть перезапущен или убит, в зависимости от политики управления ресурсами на кластере. Ограничения помогают предотвратить ситуации, когда один под использует слишком много ресурсов и тем самым влияет на работу других подов.
    
    Пример использования в ямлике пода:
    
    ```YAML
    apiVersion: v1
    kind: Pod
    metadata:
      name: mypod
    spec:
      containers:
      - name: mycontainer
        image: myimage
        resources:
          requests:         #Минимум ресурсов
            memory: "64Mi"
            cpu: "250m"     # == 0.25 CPU
          limits:           #Максимум русурсов
            memory: "128Mi"
            cpu: "500m"
    ```
    
      
    
- **==Каким образом в docker реализована изоляция контейнеров друг от друга? Какие средства linux для этого используются?==**
    
    В Docker изоляция контейнеров достигается с помощью нескольких функций ядра Linux, включая **namespaces** и **cgroups**.
    
    ==**Namespaces**== обеспечивают изоляцию рабочего пространства, включая идентификаторы процессов (PID), сеть (Network), пользователей (User), файловые системы (Mount) и другие. Каждый контейнер работает в своем собственном namespace, что предотвращает его взаимодействие с процессами в других namespaces.
    
    ==**Cgroups**== (Control Groups) позволяют ограничивать и изолировать ресурсы, которые контейнер может использовать, включая CPU, память, дисковое пространство и сетевой трафик. Это помогает управлять нагрузкой на систему и предотвращает ситуации, когда один контейнер может использовать все доступные ресурсы, оставляя другие контейнеры без необходимых ресурсов.
    
    Вот пример команды, которая создает новый namespace для контейнера в Docker:
    
    ```Shell
    docker run --name my_container --network my_network my_image
    ```
    
    Эта команда запускает новый контейнер с именем `my_container`, используя образ `my_image` и подключает его к сетевому namespace `my_network`.
    
    Использование этих механизмов позволяет Docker обеспечивать высокий уровень изоляции и безопасности для контейнеров, работающих на одном хосте.