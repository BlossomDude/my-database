## Аутентификация

Каждый запрос управляется через API Server, вне зависимости используете ли вы команду `kubectl` или напрямую отправляете POST запрос - все они проходят через `kube-apiserver`.
`kube-apiserver` аутентифицирует пользователя перед обработкой запроса к API.

Способы аутентификации:
- Иметь файл с именами и паролями пользователей (или токенами)
Для данного метода необходимо иметь `csv` файл с пользователями в данном формате:
```csv
password123, user1, u0001, group1
password123, user2, u0002, group1 
password123, user3, u0003, group1
```
4 столбец указывающий группу пользователя - опционален.

После этого необходимо передать при запуске API серверу параметр:
`--basic-auth-file=user-details.csv`
Для обращении через curl используйте параметр `-u`:
`curl -v -k https://master-node:6443/api/v1/pods -u "user1:password123"`

Так же можно использовать вместо пароля - токен. Для этого нужно указать другой параметр для `kube-apiserver`:
`--token-auth-file=user-tokens.csv`
Для обращении через curl используйте header:
`curl https://master-node:6443/api/v1/pods --header "Authorixation: Bearer <token>"

- Использовать сертификаты
- Использовать стороннее ПО (LDAP, Kerberos etc)
---
## Создание сертификатов

В кластере есть два типа сертификатов:
- Клиентские сертификаты - для отправки запросов (shcheduler, controller, proxy и админ)
- Серверные сертификаты - для получение обращений

У каждого компонента кластера (etcd, apiservre, contoller etc.) должны быть свои сертификаты.

>[!info]
>У кластера k8s должен быть как минимум один центр сертификации(CA)

#### Генерация ключей

Для генерации ключей можно использовать команду `openssl`. 
>[!important]
>Сертификаты компонентов kubernetes которые относятся к контрольной плоскости должны иметь `CN=SYSTEM-<name>`
>Узлы - `CN=system:node:<name>`
>[https://github.com/mmumshad/kubernetes-the-hard-way/tree/master/tools](https://github.com/mmumshad/kubernetes-the-hard-way/tree/master/tools)
##### Генерация CA(root) сертификата и ключа:
```bash
# Генерируем обычный rsa ключ
openssl genrsa -out ca.key 2048 

# Создаем запрос на подпись с именем компонента
openssl req -new -key ca.key -subj "/CN=KUBERNETES-CA/O=system:masters" -out ca.csr

# Подписываем сертификат. В итоге у нас сертификат и ключ, ca.key и ca.crt
openssl x509 -req -in ca.csr -signkey ca.key -out ca.crt
```

###### Генерация сертификата для Администратора кластера:
```bash
# Генерируем обычный rsa ключ
openssl genrsa -out admin.key 2048 

# Создаем запрос на подпись с именем компонента
openssl req -new -key ca.key -subj "/CN=kube-admin" -out admin.csr

# Подписываем сертификат. В итоге у нас сертификат и ключ, ca.key и ca.crt
openssl x509 -req -in admin.csr -CA ca.crt -CAkey ca.key -out admin.crt
```
 Все аналогично созданию рутовых ключей. В отличии от того что мы подписываем сертификат рутовым ключом и сертификатом.

###### Подписание сертификата администратором k8s

>[!info]
>За выполнение операция связанных с сертификатами отвечают два контроллера:
>- CSR-SIGNING
>- CSR-APPROVING

Администратор кластера может подписывать сертификаты пользователей.

Например пользователь создает сертификат и создает запрос на подпись:
- `openssl genrsa -out user.key 2048`
- `openssl -req -new user.key -subj "/CN=user" -out user.csr`

После этого администратор кодирует в base64 csr и создает объект типа `CrtificatesSigningRequest`:
```yaml
apiVersion: certificates.k8s.io/v1 
kind: CertificateSigningRequest 
metadata: 
  name: my-csr 
spec: 
  groups: 
    - system:authenticated 
  request: <Paste the base64 encoded value of the CSR file> 
  signerName: kubernetes.io/kube-apiserver-client 
  usages: 
  - client auth
```

Можно посмотреть весь список данных объектов:
`kubectl get csr`

И апрувнуть если это необходимо:
`kubectl certificate approve my-csr`

Далее ключ можно получить из файла манифеста того же csr, декодировав его.