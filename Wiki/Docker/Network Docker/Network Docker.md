---
Owner: Blossom Dude
Last edited time: 2024-07-09T15:22
Created time: 2023-11-14T17:50
---
Есть три типа сети:

`Bridge` - Сеть по умолчанию. Тип сети в котором контейнеры подключаются к виртуальной локальной сети на docker host. По умолчанию докер создает сеть `172.17.0.1` с именем `bridge`, на хосте он называется `docker0`.
Так же мы можем создать свою:
	`docker network create --driver bridge --subnet 182.18.0.0/16 my-custom-network`


`NONE` - `docker run --network=none` Контейнер не будет являться членом какой-то сети и не будет иметь доступ в сеть.

`HOST` - `docker run --network=host` Предоставление контейнеру полностью расходовать сетевые ресурсы хоста.

`Overlay` - `--network=any_net` одна сеть на нескольких контейнерах. Это требуется для Docker Swarm и не предназначено для общего использования в других режимах. Мы поговорим о Swarm дальше в курсе.

`MACVLAN` - macvlan драйвер создает реальный MAC-адрес для каждого из контейнеров, а затем представляет их в сети через выбранный интерфейс. Таким образом, все контейнеры появляются непосредственно в базовой сети. Поддерживает два режима работы: `Bridge mode`, т.е. режим моста, и `802.1Q trunk bridge mode`, когда применяется фильтрация по стандарту 802.1Q.  
  
`docker network create --driver macvlan -o parent=enp1s0 my-vlan`  
Для работы  
`MACVLAN` нам нужно создать сеть с установкой этого типа драйвера и указать сетевой интерфейс хоста, через драйвер будет работать с трафиком

`IPVLAN Network` - Похоже на предыдущий тип сети, он также может связать нескольких контейнеров между разными хостами, но использует L2 Bridge.


Создаем пользовательскую сеть, тип сети bridge и указываем адрес сети с маской.

  

> [!important]  
> Докер имеет встроенный DNS-сервер (127.0.0.11), поэтому общение между контейнерами производить лучше по имени  

  

## Docker-Proxy

В случае обращения по внешнему адресу хоста, запрос передается процессу `docker-proxy`, который знает, что должен передать этот запрос контейнеру. Именно он пересылает его на правильный адрес и порт контейнера в частной сети хоста. Обратный трафик от запроса проходит через тот же маршрут.  
  

Мы можем вообще отключить прокси при помощи флага `userland-proxy=false`. В этом случае dockerd будет использовать `hairpin NAT` для маршрутизации трафика между локальными контейнерами. Что именно лучше - выбирать тебе:

- `docker-proxy` - это приложение, и у него есть ограничения на пропускную способность для больших файлов.
- `hairpin NAT` - это просто правила iptables, и они будут производительнее при высокой загруженности. Но их иногда приходится править вручную, особенно для внутреннего взаимодействия контейнеров, поскольку теперь всё ходит через внешний интерфейс хоста.